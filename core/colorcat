#!/usr/bin/env bash
set -e

is_verbose=false
is_edit=false
session_file=
pass_args=()
while [ "$#" -gt 0 ] ; do
  key="$1"
  case $key in
      --verbose)
      is_verbose=true
      shift
      ;;
      --edit)
      is_edit=true
      shift
      ;;
      -f|--session-file)
      session_file="$2"
      shift ; shift
      ;;
      *)
      pass_args+=("$key")
      shift
      ;;
  esac
done

# pass_args å‚æ•°ç›´æ¥relayç»™cat

declare -A color_map
color_map[black]='[30m'
color_map[red]='[31m'
color_map[green]='[32m'
color_map[yellow]='[33m'
color_map[blue]='[34m'
color_map[magenta]='[35m'
color_map[cyan]='[36m'
color_map[white]='[37m'
color_reset_code='[0m'

# ä¼˜å…ˆä½¿ç”¨gsed
used_sed() {
  if type gsed >/dev/null 2>&1 ; then
    gsed "$@"
  else
    sed "$@"
  fi
}

# æ³¨æ„äº‹é¡¹ï¼š
# back referenceä»2å¼€å§‹ï¼Œå› ä¸ºä¸ºäº†æ·»åŠ é¢œè‰²åœ¨è¾“å…¥çš„reå¤–é¢å·²ç»æ·»åŠ ä¸€å±‚()

history_file=.colorcat.hist
if [ -n "$SHELLPACK_HOME" ] ; then
  history_file="${SHELLPACK_HOME}/$history_file"
fi

if [ -n "$session_file" ] ; then
  history_file="$session_file"
fi

declare -a shellpack_lru_entry_args=( \
  '--name' 'colorcat session' \
  '--session-file' "$history_file" \
  '--example-entry' "#Format:\n#color: <red|green|blue|black|yellow|magenta|cyan|white>\n#re: ^re1\n#re: ^re2\$" \
)

if $is_edit ; then
  shellpack_lru_entry_args+=('--edit')
fi
if $is_verbose ; then
  shellpack_lru_entry_args+=('--verbose')
fi

selected_entry=$(shellpack_lru_entry "${shellpack_lru_entry_args[@]}")
if $is_edit ; then
  exit
fi

# entry historyæ–‡ä»¶æ ¼å¼
# 1. entry
# ============
# color: red|green
# re: xxx
# re: xxx
# color: blue
# re: yyy
# ------------
# 2. entryä¹‹é—´çš„åˆ†éš”ç¬¦
# 
# ============

colorcat_imp() {
  local concated_cmd_bre=
  local concated_cmd_re=
  local current_color=
  local re_type=
  local re_expr=
  {
    while read -r line ; do
      if [[ "$line" =~ ^color:[[:blank:]]*([^[:space:]]+) ]] ; then
        current_color="${BASH_REMATCH[1]}"
        continue
      fi

      local color_code="${color_map[$current_color]}"
      if [ -z "$color_code" ] ; then
        1>&2 echo "Color not supported: $current_color, using white instead."
        color_code="${color_map[white]}"
      fi

      if [[ "$line" =~ ^(re|bre):[[:blank:]]?(.+) ]] ; then
        re_type="${BASH_REMATCH[1]}"
        re_expr="${BASH_REMATCH[2]}"
        local parenthesis1
        local parenthesis2
        parenthesis1="$([ "$re_type" = "re" ] && echo '(' || echo '\(')"
        parenthesis2="$([ "$re_type" = "re" ] && echo ')' || echo '\)')"
        local cmd="s/${parenthesis1}${re_expr}${parenthesis2}/${color_code}\1${color_reset_code}/g"
        if [ "$re_type" = "re" ] ; then
          if [ -n "$concated_cmd_re" ] ; then
            concated_cmd_re+=";${cmd}"
          else
            concated_cmd_re="${cmd}"
          fi
        elif [ "$re_type" = "bre" ] ; then
          if [ -n "$concated_cmd_bre" ] ; then
            concated_cmd_bre+=";${cmd}"
          else
            concated_cmd_bre="${cmd}"
          fi
        else
          1>&2 echo "Invalid re type, ignoring: $line"
          continue
        fi
      fi
    done
  } <<<"$1"

  if [ $is_verbose ] ; then
    1>&2 [ -n "$concated_cmd_re" ] && echo "real re: $concated_cmd_re"
    1>&2 [ -n "$concated_cmd_bre" ] && echo "real bre: $concated_cmd_bre"
  fi

  if [ -n "$concated_cmd_re" ] && [ -n "$concated_cmd_bre" ] ; then
    cat "${pass_args[@]}" | used_sed "$concated_cmd_bre" | used_sed -E "$concated_cmd_re"
  elif [ -n "$concated_cmd_re" ] ; then
    cat "${pass_args[@]}" | used_sed -E "$concated_cmd_re"
  elif [ -n "$concated_cmd_bre" ] ; then
    cat "${pass_args[@]}" | used_sed "$concated_cmd_bre"
  else
    cat "${pass_args[@]}"
  fi
}

if [[ "$selected_entry" =~ ^[[:space:]]*$ ]] ; then
  cat "${pass_args[@]}"
else
  colorcat_imp "$selected_entry"
fi
