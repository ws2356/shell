#!/usr/bin/env bash
set -e

is_extended_re=false
for arg in "$@" ; do
  if [ "$arg" = '-E' ] ; then
    is_extended_re=true
  fi
done
# å‚æ•°ç›´æŽ¥relayç»™sed
pass_args=("$@")

# ä¼˜å…ˆä½¿ç”¨gsed
used_sed() {
  if type gsed >/dev/null 2>&1 ; then
    gsed "$@"
  else
    sed "$@"
  fi
}

# æ³¨æ„äº‹é¡¹ï¼š
# back referenceä»Ž2å¼€å§‹ï¼Œå› ä¸ºä¸ºäº†æ·»åŠ é¢œè‰²åœ¨è¾“å…¥çš„reå¤–é¢å·²ç»æ·»åŠ ä¸€å±‚()

history_file=.colorcat.hist
# entry historyæ–‡ä»¶æ ¼å¼
# 1. entry
# ============
# color: red|green
# re: xxx
# re: xxx
# color: blue
# re: yyy
# ------------
# 2. entryä¹‹é—´çš„åˆ†éš”ç¬¦
# 
# ============

declare -A color_map
color_map[black]='[30m'
color_map[red]='[31m'
color_map[green]='[32m'
color_map[yellow]='[33m'
color_map[blue]='[34m'
color_map[magenta]='[35m'
color_map[cyan]='[36m'
color_map[white]='[37m'
color_reset_code='[0m'

load_history() {
  if [ -r "$history_file" ] ; then
    cat "$history_file"
  fi
}

trim_entry() {
  sed 's/^[[:space:]]\{1,\}//' | sed 's/^[[:space:]]\{1,\}$//' | sed '/^$/ d'
}

# è¿™ä¸ªå‡½æ•°éœ€è¦åœ¨pipeçŽ¯å¢ƒä¸‹ï¼Œé€šè¿‡ç»ˆç«¯å’Œç”¨æˆ·äº¤äº’ï¼ŒèŽ·å–åŽé¢æ“ä½œéœ€è¦çš„é€‰é¡¹
edit_new_entry() {
  # é¿å…å‘stdoutè¾“å‡ºä»»ä½•ä¸œè¥¿
  1>&2 echo -e "Format: \n color: <red|green|blue|black|yellow|magenta|cyan|white>\n  re: ^re1\n  re: ^re2\$"
  local ttyname
  ttyname=/dev/$(ps -p "$$" -o tty | sed -n '$p' | sed 's/[[:space:]]\{1,\}$//')
  <"$ttyname" trim_entry
}

edit_entry='Or, edit new entry'

is_new_entry=false
loaded_history=$(load_history)
selected_entry=
if [ -n "$loaded_history" ] ; then
  declare -a entries
  {
    while read -r -d '' line ; do
      if [ -z "$line" ] ; then
        continue
      fi
      entries+=("$line")
    done
  } <<<"$loaded_history"

  if [ "${#entries[@]}" -gt 0 ] ; then
    1>&2 echo "Total number of history entries: ${#entries[@]}"$'\n'"Choose one:"
    entries+=("$edit_entry")
    ttyname=/dev/$(ps -p "$$" -o tty | sed -n '$p' | sed 's/[[:space:]]\{1,\}$//')
    {
      select choice in "${entries[@]}" ; do
        if [ -z "$choice" ] ; then
          continue
        fi
        if [ "$choice" = "$edit_entry" ] ; then
          selected_entry=$(edit_new_entry)
          is_new_entry=true
        else
          selected_entry="$choice"
        fi
        break
      done
    } 1>&2 <"${ttyname}"
  else
    selected_entry=$(edit_new_entry)
    is_new_entry=true
  fi
fi

if [ -z "$loaded_history" ] ; then
  # å®žéªŒè¡¨æ˜Žï¼Œå‘½ä»¤æ›¿ä»£çš„stdoutè¾“å‡ºä¸ä¼šå½±å“å½“å‰è¿›ç¨‹çš„stdout
  selected_entry=$(edit_new_entry)
  is_new_entry=true
fi

1>&2 echo "Selected_entry: ${selected_entry}"

if $is_new_entry ; then
  echo "${selected_entry}" >>"$history_file"
fi

colorcat_imp() {
  local concated_re=
  local color=
  declare -a remain_part
  {
    while read -r line ; do
      if [ "${#remain_part[@]}" -gt 0 ] ; then
        remain_part+=("$line")
        continue
      fi

      if [[ "$line" =~ ^color:[[:blank:]]*(.+) ]] ; then
        if [ -z "$concated_re" ] ; then
          color="${BASH_REMATCH[1]}"
        else
          remain_part+=("$line")
        fi
        continue
      fi

      if [[ "$line" =~ ^re:[[:blank:]]?(.+) ]] ; then
        concated_re+="${BASH_REMATCH[1]}"
      fi
    done
  } <<<"$1"

  local color_code="${color_map[$color]}"
  if [ -z "$color_code" ] ; then
    1>&2 echo "Color not supported: $color"
    exit 1
  fi

  local parenthis1
  local parenthis2
  parenthis1="$($is_extended_re && echo '(' || echo '\(')"
  parenthis2="$($is_extended_re && echo ')' || echo '\)')"
  local re="s/${parenthis1}${concated_re}${parenthis2}/${color_code}\1${color_reset_code}/g"
  if [ "${#remain_part[@]}" -gt 0 ] ; then
    IFS_=$IFS
    export IFS=$'\n'
    remain_part_str="${remain_part[*]}"
    export IFS=$IFS_
    used_sed "${pass_args[@]}" "$re" | colorcat_imp "$remain_part_str"
  else
    used_sed "${pass_args[@]}" "$re"
  fi
}

colorcat_imp "$selected_entry"
